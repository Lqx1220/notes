## 索引

#### 索引示意图

![image-20210813121235413](https://i.loli.net/2021/08/13/NgorCMtwUlEkXKa.png)

#### 索引特点

- 优点
  1. 提高数据检索的效率，降低数据库的IO成本。
  2. 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。
- 缺点
  - 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间
    的。
  - 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为
    更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所
    带来的键值变化后的索引信息。

#### 索引结构

|     索引      |   InnoDB引擎    | MyISAM引擎 | Memory引擎 |
| :-----------: | :-------------: | :--------: | :--------: |
|   BTREE索引   |      支持       |    支持    |    支持    |
|   HASH索引    |     不支持      |   不支持   |    支持    |
|  R-tree索引   |     不支持      |    支持    |   不支持   |
| Full-text索引 | 5.6版本之后支持 |    支持    |   不支持   |

我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。

##### BTREE 结构

BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：

- 树中每个节点最多包含m个孩子。
- 除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。
- 若根节点不是叶子节点，则至少有两个孩子。
  所有的叶子节点都在同一层。
- 每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] <= n <= m-1

**BTRREE树和二叉树相比,查询数据的效率更高,因为对于相同的数据量来说,BTREE层级结构比二叉树小,因此搜索速度块.**



以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] <= n <= m-1。所以 2 <= n <=4 。当n>4时，中间节点分裂到父节点，两边节点分裂。

插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。

演变过程如下：

1). 插入前4个字母 C N G A

![image-20210813131939682](https://i.loli.net/2021/08/13/Fe617EK5xaB9NPy.png)

2). 插入H，n>4，中间元素G字母向上分裂到新的节点

![image-20210813131958452](https://i.loli.net/2021/08/13/Z8BeXptqWEgriVP.png)

3). 插入E，K，Q不需要分裂

![image-20210813132009481](https://i.loli.net/2021/08/13/RGOAq9yvBgMtpxf.png)

4). 插入M，中间元素M字母向上分裂到父节点G

![image-20210813132019712](https://i.loli.net/2021/08/13/z1blRV2oWtQjqLH.png)

5). 插入F，W，L，T不需要分裂

![image-20210813132033472](https://i.loli.net/2021/08/13/ErjtXpgfYmisH6K.png)

6). 插入Z，中间元素T向上分裂到父节点中

![image-20210813132053616](https://i.loli.net/2021/08/13/j39nfVESX1e6Mxs.png)

7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂

![image-20210813132107059](https://i.loli.net/2021/08/13/QCTyDzM9f5KbcVj.png)

8). 最后插入S，NPQR节点n>5，中间节点Q向上分裂，但分裂后父节点DGMT的n>5，中间节点M向上分裂

![image-20210813132121040](https://i.loli.net/2021/08/13/mqEC2glpnBGVSLJ.png)

##### B+TREE 结构

B+Tree为BTree的变种，B+Tree与BTree的区别为：

1.  n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。
2.  B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。
3.  所有的非叶子节点都可以看作是key的索引部分。

**由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。**

![image-20210813143259594](https://i.loli.net/2021/08/13/78GVIPtW5pmvaKU.png)

##### MySQL中的B+Tree

MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。

![image-20210813143404171](https://i.loli.net/2021/08/13/GOkutfP8RNiwljE.png)

#### 索引的分类

1. 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引
2. 唯一索引 ：索引列的值必须唯一，但允许有空值
3. 复合索引 ：即一个索引包含多个列

#### 索引语法

- 创建索引

```mysql
CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name/*索引类型*/
[USING index_type]/*索引结构类型*/
ON tbl_name(index_col_name,...)/*哪张表的哪些字段*/
index_col_name : column_name[(length)][ASC | DESC]
```

- 查看索引

```mysql
show index  from table_name;
```

- 删除索引

```mysql
drop index index_name on table_name	
```

- alter命令

  - 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL

  ```mysql
  alter table tb_name add primary key(column_list);
  ```

  - 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）

  ```mysql
  alter table tb_name add unique index_name(column_list);
  ```

  - 添加普通索引， 索引值可以出现多次。

  ```mysql
  alter table tb_name add index index_name(column_list);
  ```

  - 该语句指定了索引为FULLTEXT， 用于全文索引

  ```mysql
  alter table tb_name add fulltext index_name(column_list);
  ```

#### 索引设计原则

- 对查询频次较高，且数据量比较大的表建立索引。
- 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。
- 使用唯一索引，区分度越高，使用索引的效率越高。
- 索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。
- 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。
- 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。

```mysql
/*创建复合索引:*/
CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);
/*就相当于
对name 创建索引 ;
对name , email 创建了索引 ;
对name , email, status 创建了索引 ;*/
```

## 视图

#### 视图概述

视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。

#### 视图优点

- 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。
- 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。
- 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。

#### 视图语法

- 创建视图

  ```mysql
  CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
  VIEW view_name [(column_list)]
  AS select_statement
  [WITH [CASCADED | LOCAL] CHECK OPTION]
  ```

- 修改视图

  ```mysql
  ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
  VIEW view_name [(column_list)]
  AS select_statement
  [WITH [CASCADED | LOCAL] CHECK OPTION]
  ```

  ```
  WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。
  LOCAL ： 只要满足本视图的条件就可以更新。
  CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.
  ```

- 查看视图

  ```mysql
  show tables
  ```

- 删除视图

  ```mysql
  DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT 1 | CASCADE]
  ```

  

## 存储过程和函数

#### 存储过程的概述

