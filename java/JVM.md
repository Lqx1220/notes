## JVM基础

#### 定义

Java程序的运行环境(Java二进制字节码的运行环境)

#### 好处

- 一次编写,到处运行
- 自动内存管理,垃圾回收功能
- 数组下标越界检查
- 多态

#### JVM和JDK的区别

<img src="https://i.loli.net/2021/09/25/Ze9FyMDco12rEAS.png" alt="image-20210925143345936" style="zoom:50%;" />

## JVM内存结构

- JVM执行流程

  二进制字节码→解释器→机器码→CPU

#### 程序计数器

###### 作用

记住下一条JVM指令的执行地址

###### 特点

- 线程私有
  - CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码
  - 程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令
- 不会存在内存溢出

#### 虚拟机栈

###### 定义

- 每个**线程**运行需要的内存空间，称为**虚拟机栈**
- 每个栈由多个**栈帧**组成，对应着每次调用方法时所占用的内存
- 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**

###### 问题辨析

- 垃圾回收是否涉及栈内存？
  - **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。
- 栈内存的分配越大越好吗？
  - 不是。因为**物理内存是一定的**，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。
- 方法内的局部变量是否是线程安全的？
  - 如果方法内**局部变量没有逃离方法的作用范围**，则是**线程安全**的
  - 如果**局部变量引用了对象**，并**逃离了方法的作用范围**，则需要考虑线程安全问题

###### 内存溢出

- 原因
  - 虚拟机栈中，**栈帧过多**（无限递归）
  - 每个栈帧**所占用过大**

#### 本地方法栈

###### 定义

一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法

#### 堆

###### 定义

通过new关键字**创建的对象**都会被放在堆内存

###### 特点

- **所有线程共享**，堆内存中的对象都需要**考虑线程安全问题**
- 有垃圾回收机制

###### 堆内存溢出

**java.lang.OutofMemoryError** ：java heap space. 堆内存溢出

#### 方法区

###### 结构

<img src="https://i.loli.net/2021/09/25/HwiGyWk7ON1CgMB.png" alt="image-20210925164122404" style="zoom:50%;" />

###### 定义

存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法

###### 内存溢出

- 1.8以前会导致**永久代**内存溢出
- 1.8以后会导致**元空间**内存溢出

###### 常量池

就是一张表,虚拟机指令根据这张常量表找到要执行的类名,方法名,参数类型,字面量等信息

###### 运行时常量池

当类被加载到虚拟机后常量池信息就会放到运行时常量池中,并把里面的符号地址变为真实地址

###### StringTable

- 特征
  - 常量池中的字符串仅是符号，只有**在被用到时才会转化为对象**
  - 利用串池的机制，来避免重复创建字符串对象
  - 字符串**变量**拼接的原理是**StringBuilder**
  - 字符串**常量**拼接的原理是**编译器优化**
  - 可以使用**intern方法**，主动将串池中还没有的字符串对象放入串池中
  - **注意**：无论是串池还是堆里面的字符串，都是对象

- intern方法 1.8

  调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

  - 如果串池中没有该字符串对象，则放入成功
  - 如果有该字符串对象，则放入失败

  无论放入是否成功，都会返回串池中的字符串对象

  **注意**：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象

- intern方法 1.6

  调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中

  - 如果串池中没有该字符串对象，会将该字符串对象**复制**一份，再放入到串池中
  - 如果有该字符串对象，则放入失败

  无论放入是否成功，都会返回串池中的字符串对象

  **注意**：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象

- StringTable 垃圾回收

  StringTable在内存紧张时，会发生垃圾回收

- StringTable调优
  - 因为StringTable是由HashTable实现的，所以可以**适当增加HashTable桶的个数**，来减少字符串放入串池所需要的时间 `-XX:StringTableSize=xxxx`
  - 考虑是否需要将字符串对象入池可以通过intern方法减少重复入池

#### 直接内存

###### 特点

- 属于操作系统,常见NIO操作时,用于数据缓冲区
- 分配回收成本高,但读写性能高
- 不受JVM内存回收管理

###### 读写流程

- 文件读写流程

<img src="https://i.loli.net/2021/09/27/5XsifDOdzIa7j3p.png" alt="image-20210926090537738" style="zoom:50%;" />

- 使用DirectBuffer					

<img src="https://i.loli.net/2021/09/27/brMkJtpGAgOHxFs.png" alt="image-20210926090603623" style="zoom:50%;" />

直接内存是操作系统和Java代码**都可以访问的一块区域**，无需将代码从系统内存复制到Java堆内存，从而提高了效率

###### 内存释放

直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过**unsafe.freeMemory**来手动释放

- 使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法
- ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存

## 垃圾回收

#### 引用计数法

###### 缺点

循环引用时，两个对象的计数都为1，导致两个对象都无法被释放

<img src="https://i.loli.net/2021/09/26/DnlRK2iecUNxtXM.png" alt="image-20210926090832545" style="zoom:50%;" />

#### 可达性分析算法

- JVM中的垃圾回收器通过**可达性分析**来探索所有存活的对象
- 扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果**找不到，则表示可以回收**
- 可以作为GC Root的对象
  - Java核心类对象
  - Java本地方法栈
  - 正在被加锁的对象
  - 活动线程

#### 五种引用

###### 强引用

- 只有GC Root**都不引用**该对象时，才会回收**强引用**对象

###### 软引用

- 当GC Root指向软引用对象时，在**内存不足时**，会**回收软引用所引**

###### 弱引用

- 只有弱引用引用该对象时，在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象

###### 虚引用

- 必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

###### 终结器引用

- 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象

###### 引用队列

- 软引用和弱引用**可以配合**引用队列
  - 在**弱引用**和**虚引用**所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象
- 虚引用和终结器引用**必须配合**引用队列
  - 虚引用和终结器引用在使用时会关联一个引用队列

## 垃圾回收算法

#### 标记-清除

<img src="https://i.loli.net/2021/09/26/9vU2iOwucKjbsxX.png" alt="image-20210926095802048" style="zoom:50%;" />

###### **定义**：

标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间

- 这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接**覆盖**这段内存

###### **缺点**：

**容易产生大量的内存碎片**，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢

#### 标记-整理

<img src="https://i.loli.net/2021/09/26/5rAd4HR29hjzk1i.png" alt="image-20210926100029424" style="zoom:50%;" />

###### 定义

标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低

#### 复制

<img src="https://i.loli.net/2021/09/26/Yda1rQLowhBiMOf.png" alt="image-20210926100834939" style="zoom:50%;" />

<img src="https://i.loli.net/2021/09/27/MIilRH4hJo9xQDP.png" alt="image-20210926100850167" style="zoom:50%;" />

<img src="https://i.loli.net/2021/09/26/hzv8YpDA1NWnMZl.png" alt="image-20210926100905677" style="zoom:50%;" />

<img src="https://i.loli.net/2021/09/27/9qv5iclwWdVADym.png" alt="image-20210926100921646" style="zoom: 50%;" />

###### 定义

将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。

## 分代垃圾回收

<img src="https://i.loli.net/2021/09/26/hPOTH6aVAyWeIxF.png" alt="image-20210926102253956" style="zoom:50%;" />

#### 回收流程

新创建的对象都被放在了**新生代的伊甸园**中

<img src="https://i.loli.net/2021/09/26/kpZsIaP9dwJM46h.png" alt="image-20210926102357567" style="zoom:50%;" />

当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 **Minor GC**

Minor GC 会将**伊甸园和幸存区FROM**存活的对象**先**复制到 **幸存区 TO**中， 并让其**寿命加1**，再**交换两个幸存区**

<img src="https://i.loli.net/2021/09/27/Gg9acfEyK7uCL2p.png" alt="image-20210926102450818" style="zoom:50%;" />

再次创建对象，若新生代的伊甸园又满了，则会**再次触发 Minor GC**（会触发 **stop the world**， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，**还会回收幸存区中的垃圾**，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象**寿命加1**

<img src="https://i.loli.net/2021/09/26/NlDLKgsYpZx5jWP.png" alt="image-20210926102524202" style="zoom:50%;" />

如果幸存区中的对象的**寿命超过某个阈值**（最大为15，4bit），就会被**放入老年代**中

<img src="https://i.loli.net/2021/09/27/USvQxBCy2rZFsz5.png" alt="image-20210926102546677" style="zoom:50%;" />

如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发**Full GC**，扫描**新生代和老年代中**所有不再使用的对象并回收

#### GC分析

###### 大对象处理策略

- 当遇到一个**较大的对象**时，就算新生代的**伊甸园**为空，也**无法容纳该对象**时，会将该对象**直接晋升为老年代**

###### 线程内存溢出

- 某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行
- 这是因为当一个线程**抛出OOM异常后**，**它所占据的内存资源会全部被释放掉**，从而不会影响其他线程的运行，**进程依然正常**

## 垃圾回收器

#### 串行

###### 特点

- 单线程
- 内存较小,CPU核数较少

<img src="https://i.loli.net/2021/09/26/Fb5WhIG4AX8eQ9f.png" alt="image-20210926115746927" style="zoom:50%;" />

###### 安全点

让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象

因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入**阻塞**状态

###### Serial 收集器

- 特点：单线程、简单高效（与其他收集器的单线程相比），采用**复制算法**。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）

###### Serial Old 收集器

- Serial Old是Serial收集器的老年代版本

- 特点：同样是单线程收集器，采用**标记-整理算法**

#### 吞吐量优先

- 多线程
- 堆内存较大，多核CPU
- 单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短
- **JDK1.8默认使用**的垃圾回收器

<img src="https://i.loli.net/2021/09/27/TdhiVb9qrJLAH8G.png" alt="image-20210926120327266" style="zoom:50%;" />

###### Parallel Scavenge 收集器

- 特点：属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区），又是并行的多线程收集器**特点**：属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区），又是并行的多线程收集器

###### Parallel Old 收集器

- 是Parallel Scavenge收集器的老年代版本

- 特点：多线程，采用**标记-整理算法**（老年代没有幸存区）

#### 响应时间优先

- 多线程
- 堆内存较大，多核CPU
- 尽可能让单次STW时间变短（尽量不影响其他线程运行）

<img src="https://i.loli.net/2021/09/27/hrpdXi3yPJALD6c.png" alt="image-20210926123609679" style="zoom:50%;" />

###### CMS 收集器

Concurrent Mark Sweep，一种以获取**最短回收停顿时间**为目标的**老年代**收集器

- 特点：基于**标记-清除算法**实现。并发收集、低停顿，但是会产生内存碎片

- 初始标记：标记GC Roots能直接到的对象。速度很快但是**仍存在Stop The World问题**

- 并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行

- 重新标记：为了**修正并发标记期间**因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题

- 并发清除：对标记的对象进行清除回收

CMS收集器的内存回收过程是与用户线程一起**并发执行**的

###### ParNew 收集器

- ParNew收集器其实就是Serial收集器的多线程版本

- 特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题,并发失败会转换为Serial Old 收集器

#### G1

###### 适用场景

- 同时注重吞吐量和低延迟（响应时间）
- 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域
- 整体上是**标记-整理**算法，两个区域之间是**复制**算法

###### G1垃圾回收阶段

<img src="https://i.loli.net/2021/09/26/g27tThMkxL8uHji.png" alt="image-20210926142947997" style="zoom:50%;" />

新生代伊甸园垃圾回收—–>内存不足，新生代回收+并发标记—–>回收新生代伊甸园、幸存区、老年代内存——>新生代伊甸园垃圾回收(重新开始)

###### CM：并发标记

Concurrent Mark

- 在 Young GC 时会**对 GC Root 进行初始标记** (初始标记找到根对象)
- 在老年代**占用堆内存的比例**达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定(并发标记从根对象出发找到其他引用对象)

###### Mixed Collection

- 全面的回收
  - 最终标记 (会STW)
  - **拷贝**存活 (会STW)

- -XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间
  - 为了保证时间不超过设定的停顿时间，会**回收最有价值的老年代**（回收后，能够得到更多内存）

###### Full GC

G1在老年代内存不足时（老年代所占内存超过阈值）

- 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
- 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

###### Young Collection 跨代引用

- 新生代回收的跨代引用（老年代引用新生代）问题

  <img src="https://i.loli.net/2021/09/27/n9ld6hPtRcLk1Jo.png" alt="image-20210926150519993" style="zoom:50%;" />

- 卡表与Remembered Set
  - Remembered Set 存在于E中，用于保存新生代对象对应的脏卡
    - 脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡

- 在引用变更时通过post-write barried + dirty card queue

- concurrent refinement threads 更新 Remembered Set

<img src="https://i.loli.net/2021/09/27/8OhqFXljW3Jto9s.png" alt="image-20210926150535050" style="zoom:50%;" />

###### Remark

在**并发标记过程中**，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark

过程如下

- 之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态
- 在**并发标记**阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它

###### JDK 8u20 字符串去重

过程

- 将所有新分配的字符串（底层是char[]）放入一个队列
- 当新生代回收时，G1并发检查是否有重复的字符串
- 如果字符串的值一样，就让他们**引用同一个字符串对象**
- 注意，其与String.intern的区别
  - intern关注的是字符串对象
  - 字符串去重关注的是char[]
  - 在JVM内部，使用了不同的字符串标

优点与缺点

- 节省了大量内存
- 新生代回收时间略微增加，导致略微多占用CPU

###### JDK 8u40 并发标记类卸载

- 在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类

###### JDK 8u60 回收巨型对象

- 一个对象大于region的一半时，就称为巨型对象
- G1不会对巨型对象进行拷贝
- 回收时被优先考虑
- G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉

#### GC调优

###### 调优领域

- 内存
- 锁竞争
- CPU占用
- IO
- GC

###### 新生代调优

- 新生代的特点
  - 所有的new操作分配内存都是非常廉价的
  - 死亡对象回收零代价
  - 大部分对象用过即死（朝生夕死）
  - MInor GC 所用时间远小于Full GC
- 新生代内存越大越好么？
  - 不是
    - 新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降
    - 新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长
  - 新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜

###### 幸存区调优

- 幸存区需要能够保存 **当前活跃对象**+**需要晋升的对象**
- 晋升阈值配置得当，让长时间存活的对象尽快晋升

###### 老年代调优

以 CMS 为例

- CMS 的老年代内存越大越好
- 先尝试不做调优，如果没有 Full GC 那么已经...，否则先尝试调优新生代
- 观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1/4 ~ 1/3
  -XX:CMSInitiatingOccupancyFraction=percent

## 字节码技术

 [3_类加载与字节码技术.pdf](3_类加载与字节码技术.pdf) 

